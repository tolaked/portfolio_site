import * as React from 'react';
import { createElement, createContext, useMemo, useRef as useRef$5, useContext as useContext$2, useState as useState$5, useEffect as useEffect$5 } from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

var calculateTotalDuration = ({ duration = 0.3, delay = 0, overlay = 0, }) => duration + delay - overlay || 0;

function getSequenceId(sequenceIndex, sequenceId, defaultValue) {
    if (sequenceId === undefined && sequenceIndex === undefined)
        return defaultValue || 0;
    if (sequenceIndex && sequenceIndex >= 0)
        return sequenceIndex;
    if (sequenceId)
        return sequenceId;
    return 0;
}

const { useState, useRef, useEffect } = React;
const AnimateContext = createContext({
    animationStates: {},
    register: (data) => { },
});
function AnimateGroup(props) {
    const { play, sequences = [], children } = props;
    const [animationStates, setAnimationStates] = useState();
    const animationsRef = useRef({});
    const register = (data) => {
        const { sequenceIndex, sequenceId } = data;
        if (sequenceId === undefined && sequenceIndex === undefined)
            return;
        animationsRef.current[getSequenceId(sequenceIndex, sequenceId)] = data;
    };
    useEffect(() => {
        const sequencesToAnimate = Array.isArray(sequences) && sequences.length
            ? sequences
            : Object.values(animationsRef.current);
        const localAnimationState = {};
        (play ? sequencesToAnimate : [...sequencesToAnimate].reverse()).reduce((previous, current, currentIndex) => {
            const { sequenceId, sequenceIndex } = current, restAttributes = __rest(current, ["sequenceId", "sequenceIndex"]);
            const { duration: defaultDuration, delay, overlay } = restAttributes;
            const id = getSequenceId(sequenceIndex, sequenceId, currentIndex);
            const duration = defaultDuration || 0.3;
            const currentTotalDuration = calculateTotalDuration({
                duration,
                delay,
                overlay,
            });
            const totalDuration = currentTotalDuration + previous;
            localAnimationState[id] = {
                play,
                pause: !play,
                delay: currentIndex === 0
                    ? delay || 0
                    : delay
                        ? currentTotalDuration
                        : previous,
                controlled: true,
            };
            return totalDuration;
        }, 0);
        setAnimationStates(localAnimationState);
    }, [play]);
    return (createElement(AnimateContext.Provider, { value: { animationStates, register } }, children));
}

var secToMs = (ms) => (ms || 0) * 1000;

const { useEffect: useEffect$1, useState: useState$1, useRef: useRef$1, useContext } = React;
function Animate(props) {
    const { play, children, render, start, end, complete = '', onComplete, delay = 0, duration = 0.3, easeType = 'linear', sequenceId, sequenceIndex, } = props;
    const onCompleteTimeRef = useRef$1({});
    const [style, setStyle] = useState$1(start || {});
    const { register, animationStates = {} } = useContext(AnimateContext);
    const id = getSequenceId(sequenceIndex, sequenceId);
    useEffect$1(() => {
        if ((sequenceIndex !== undefined && sequenceIndex >= 0) || sequenceId)
            register(props);
    }, []);
    useEffect$1(() => {
        setStyle(Object.assign(Object.assign({}, (play || (animationStates[id] || {}).play ? end : start)), { transition: `all ${duration}s ${easeType} ${parseFloat((animationStates[id] || {}).delay || delay)}s` }));
        if (play && (complete || onComplete)) {
            onCompleteTimeRef.current = setTimeout(() => {
                complete && setStyle(complete);
                onComplete && onComplete();
            }, secToMs(parseFloat((animationStates[id] || {}).delay || delay) + duration));
        }
        return () => {
            // @ts-ignore
            onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
        };
    }, [
        id,
        animationStates,
        play,
        duration,
        easeType,
        delay,
        onComplete,
        start,
        end,
        complete,
    ]);
    return render ? render({ style }) : createElement("div", { style: style }, children);
}

var camelCaseToDash = (camelCase) => camelCase ? camelCase.replace(/[A-Z]/g, c => `-${c.toLowerCase()}`) : '';

const generateKeyframes = keyframes => {
    const animationLength = keyframes.length;
    return keyframes.reduce((previous, keyframe, currentIndex) => {
        const keyframePercentage = animationLength === 2
            ? currentIndex * 100
            : parseFloat((100 / (animationLength - 1)).toFixed(2)) * currentIndex;
        if (typeof keyframe === 'string') {
            return `${previous} ${keyframePercentage}% {${keyframe}}`;
        }
        const keys = Object.keys(keyframe);
        if (keys.length && isNaN(+keys[0])) {
            const keyframeContent = keys.reduce((acc, key) => `${acc} ${camelCaseToDash(key)}: ${keyframe[key]};`, '');
            return `${previous} ${keyframePercentage}% {${keyframeContent}}`;
        }
        return `${previous} ${Object.keys(keyframe)[0]}% {${Object.values(keyframe)[0]}}`;
    }, '');
};
function createStyle({ keyframes, animationName, }) {
    return `@keyframes ${animationName} {${generateKeyframes(keyframes)}}`;
}

function createTag({ keyframes, animationName, }) {
    let styleTag = document.querySelector('style[data-id=rsi]');
    let index = 0;
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.setAttribute('data-id', 'rsi');
        document.head.appendChild(styleTag);
    }
    try {
        // @ts-ignore
        index = styleTag.sheet.cssRules.length;
    }
    catch (e) {
        index = 0;
    }
    try {
        // @ts-ignore
        styleTag.sheet.insertRule(createStyle({
            keyframes,
            animationName,
        }), index);
    }
    catch (e) {
        console.error('react simple animate, error found during insert style ', e); // eslint-disable-line no-console
    }
    return {
        styleTag,
        index,
    };
}

var createRandomName = () => `RSI-${Math.random()
    .toString(36)
    .substr(2, 9)}`;

var deleteRules = (sheet, deleteName) => {
    const index = Object.values(sheet.cssRules).findIndex(({ name }) => name === deleteName);
    if (index >= 0)
        sheet.deleteRule(index);
};

var getPlayState = (pause) => pause ? 'paused' : 'running';

const { useRef: useRef$2, useEffect: useEffect$2, useContext: useContext$1, useState: useState$2 } = React;
function AnimateKeyframes(props) {
    const { children, play = false, pause = false, render, duration = 0.3, delay = 0, easeType = 'linear', direction = 'normal', fillMode = 'none', iterationCount = 1, sequenceIndex, keyframes, sequenceId, } = props;
    const animationNameRef = useRef$2({
        forward: '',
        reverse: '',
    });
    const controlled = useRef$2(false);
    const styleTagRef = useRef$2({
        forward: { sheet: {} },
        reverse: { sheet: {} },
    });
    const id = getSequenceId(sequenceIndex, sequenceId);
    const { register, animationStates = {} } = useContext$1(AnimateContext);
    const forceUpdate = useState$2(false)[1];
    useEffect$2(() => {
        animationNameRef.current.forward = createRandomName();
        let result = createTag({
            animationName: animationNameRef.current.forward,
            keyframes,
        });
        styleTagRef.current.forward = result.styleTag;
        animationNameRef.current.reverse = createRandomName();
        result = createTag({
            animationName: animationNameRef.current.reverse,
            keyframes: keyframes.reverse(),
        });
        styleTagRef.current.reverse = result.styleTag;
        register(props);
        if (play)
            forceUpdate(true);
        return () => {
            deleteRules(styleTagRef.current.forward.sheet, animationNameRef.current.forward);
            deleteRules(styleTagRef.current.reverse.sheet, animationNameRef.current.reverse);
        };
    }, []);
    const animateState = animationStates[id] || {};
    let pauseValue = false;
    if (animateState.controlled && !controlled.current) {
        pauseValue = animateState.pause;
        if (!animateState.pause)
            controlled.current = true;
    }
    else {
        pauseValue = pause;
    }
    const style = {
        animation: `${duration}s ${easeType} ${animateState.delay ||
            delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(pauseValue)} ${((animateState.controlled
            ? animateState.play
            : play)
            ? animationNameRef.current.forward
            : animationNameRef.current.reverse) || ''}`,
    };
    return render ? render({ style }) : createElement("div", { style: style || {} }, children);
}

const { useState: useState$3, useEffect: useEffect$3, useRef: useRef$3 } = React;
function useAnimate(props) {
    const { start, end, complete, onComplete, delay = 0, duration = 0.3, easeType = 'linear', } = props;
    const transition = useMemo(() => `all ${duration}s ${easeType} ${delay}s`, [duration, easeType, delay]);
    const [style, setStyle] = useState$3(Object.assign(Object.assign({}, start), { transition }));
    const [isPlaying, setIsPlaying] = useState$3(false);
    const onCompleteTimeRef = useRef$3();
    const onCompleteCallbackRef = useRef$3(onComplete);
    const playRef = useRef$3();
    useEffect$3(() => {
        onCompleteCallbackRef.current = onComplete;
    }, [onComplete]);
    useEffect$3(() => () => {
        onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
    }, []);
    if (!playRef.current) {
        playRef.current = (isPlay) => {
            setStyle(Object.assign(Object.assign({}, (isPlay ? end : start)), { transition }));
            setIsPlaying(true);
            onCompleteTimeRef.current = setTimeout(() => {
                if (isPlay && (complete || onComplete)) {
                    complete && setStyle(complete);
                    onCompleteCallbackRef.current && onCompleteCallbackRef.current();
                }
                setIsPlaying(false);
            }, secToMs(delay + duration));
        };
    }
    return {
        isPlaying,
        style,
        play: playRef.current,
    };
}

function useAnimateKeyframes(props) {
    const { duration = 0.3, delay = 0, easeType = 'linear', direction = 'normal', fillMode = 'none', iterationCount = 1, keyframes, } = props;
    const animationNameRef = useRef$5({
        forward: '',
        reverse: '',
    });
    const styleTagRef = useRef$5({
        forward: { sheet: {} },
        reverse: { sheet: {} },
    });
    const { register } = useContext$2(AnimateContext);
    const [isPlaying, setIsPlaying] = useState$5(true);
    const [isPaused, setIsPaused] = useState$5(false);
    const playRef = useRef$5();
    useEffect$5(() => {
        animationNameRef.current.forward = createRandomName();
        let result = createTag({
            animationName: animationNameRef.current.forward,
            keyframes,
        });
        styleTagRef.current.forward = result.styleTag;
        animationNameRef.current.reverse = createRandomName();
        result = createTag({
            animationName: animationNameRef.current.reverse,
            keyframes: keyframes.reverse(),
        });
        styleTagRef.current.reverse = result.styleTag;
        register(props);
        return () => {
            deleteRules(styleTagRef.current.forward.sheet, animationNameRef.current.forward);
            deleteRules(styleTagRef.current.reverse.sheet, animationNameRef.current.reverse);
        };
    }, []);
    playRef.current = playRef.current ? playRef.current : (isPlay) => {
        setIsPlaying(isPlay);
    };
    const pause = (isPaused) => {
        setIsPaused(isPaused);
    };
    const style = {
        animation: `${duration}s ${easeType} ${delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(isPaused)} ${(isPlaying
            ? animationNameRef.current.forward
            : animationNameRef.current.reverse) || ''}`,
    };
    return {
        style,
        play: playRef.current,
        pause,
        isPlaying,
    };
}

const { useEffect: useEffect$4, useState: useState$4, useRef: useRef$4 } = React;
function createArrayWithNumbers(length) {
    return Array.from({ length }, () => null);
}
function useAnimateGroup(props) {
    const { sequences = [] } = props;
    const defaultArray = createArrayWithNumbers(sequences.length).map((_, index) => props.sequences[index].start);
    const [styles, setStyles] = useState$4(defaultArray);
    const [isPlaying, setPlaying] = useState$4(false);
    const animationNamesRef = useRef$4([]);
    const styleTagRef = useRef$4([]);
    const playRef = useRef$4();
    useEffect$4(() => {
        sequences.forEach(({ keyframes = false }, i) => {
            if (!Array.isArray(keyframes))
                return;
            if (!animationNamesRef.current[i]) {
                animationNamesRef.current[i] = {};
                styleTagRef.current[i] = {};
            }
            animationNamesRef.current[i].forward = createRandomName();
            let result = createTag({
                animationName: animationNamesRef.current[i].forward,
                keyframes,
            });
            styleTagRef.current[i].forward = result.styleTag;
            animationNamesRef.current[i].reverse = createRandomName();
            result = createTag({
                animationName: animationNamesRef.current[i].reverse,
                keyframes: keyframes.reverse(),
            });
            styleTagRef.current[i].reverse = result.styleTag;
        });
        return () => {
            Object.values(animationNamesRef).forEach(({ forward, reverse }, i) => {
                if (!styleTagRef[i])
                    return;
                deleteRules(styleTagRef[i].sheet, forward);
                deleteRules(styleTagRef[i].sheet, reverse);
            });
        };
    }, []);
    playRef.current = playRef.current
        ? playRef.current
        : (isPlay) => {
            let totalDuration = 0;
            const animationRefWithOrder = isPlay
                ? animationNamesRef.current
                : [...animationNamesRef.current].reverse();
            const styles = (isPlay ? sequences : [...sequences].reverse()).map((current, currentIndex) => {
                const { duration = 0.3, delay = 0, overlay, keyframes, iterationCount = 1, easeType = 'linear', direction = 'normal', fillMode = 'none', end = {}, start = {}, } = current;
                const delayDuration = currentIndex === 0 ? delay : totalDuration;
                const transition = `all ${duration}s ${easeType} ${delayDuration}s`;
                totalDuration =
                    calculateTotalDuration({ duration, delay, overlay }) +
                        totalDuration;
                return keyframes
                    ? {
                        animation: `${duration}s ${easeType} ${delayDuration}s ${iterationCount} ${direction} ${fillMode} running ${isPlay
                            ? animationRefWithOrder[currentIndex].forward
                            : animationRefWithOrder[currentIndex].reverse}`,
                    }
                    : Object.assign(Object.assign({}, (isPlay ? end : start)), { transition });
            });
            // @ts-ignore
            setStyles(isPlay ? styles : [...styles].reverse());
            setPlaying(!isPlaying);
        };
    return { styles, play: playRef.current, isPlaying };
}

export { Animate, AnimateGroup, AnimateKeyframes, useAnimate, useAnimateGroup, useAnimateKeyframes };
